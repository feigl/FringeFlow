PLATFORM 		=    SENTINEL-1A,SENTINEL-1B 
PROJECT_NAME		=    SITEU_TXXX
##------------------------------- ISCE/topsStack ----------------------##
ssaraopt = --platform=SENTINEL-1A,SENTINEL-1B 
##-------------------------------- MintPy -----------------------------##
########## 1. Load Data (--load to exit after this step)
##---------for ARIA only:
mintpy.load.processor        = aria
##---------interferogram datasets:
mintpy.load.unwFile          = ../stack/unwrapStack.vrt
mintpy.load.corFile          = ../stack/cohStack.vrt
mintpy.load.connCompFile     = ../stack/connCompStack.vrt
##---------geometry datasets:
#mintpy.load.demFile          = ../DEM/SRTM_3arcsec.dem
mintpy.load.demFile          = ../DEM/glo_90.dem
mintpy.load.incAngleFile     = ../incidenceAngle/*.vrt
mintpy.load.azAngleFile      = ../azimuthAngle/*.vrt
mintpy.load.waterMaskFile    = ../mask/watermask.msk
mintpy.network.perpBaseMax     = 100  #[1-inf, no], auto for no, max perpendicular spatial baseline in meter
mintpy.network.coherenceBased  = yes  #[yes / no], auto for no, exclude interferograms with coherence < minCoherence
mintpy.network.minCoherence    = 0.7  #[0.0-1.0], auto for 0.7

## b - Effective Coherence Ratio network modification = (threshold + MST) by default
## reference: Kang et al. (2021, RSE)
## It calculates the area ratio of each interferogram that is above a spatial coherence threshold.
## This threshold is defined as the spatial coherence of the interferograms within the input mask.
## It then finds a minimum spanning tree (MST) network with inverse of the area ratio as weight (keepMinSpanTree)
## Next it excludes interferograms if a) the area ratio < minAreaRatio AND b) not in the MST network.
mintpy.network.areaRatioBased  = auto  #[yes / no], auto for no, exclude interferograms with area ratio < minAreaRatio
mintpy.network.minAreaRatio    = auto  #[0.0-1.0], auto for 0.75

## Additional common parameters for the 2) data-driven network modification
mintpy.network.maskFile        = no  #[file name, no], auto for waterMask.h5 or no [if no waterMask.h5 found]

mintpy.reference.lalo          = auto 


mintpy.troposphericDelay.method = pyaps  #[pyaps / height_correlation / gacos / no], auto for pyaps
mintpy.troposphericDelay.weatherModel = ERA5  #[ERA5 / MERRA / NARR], auto for ERA5
mintpy.troposphericDelay.weatherDir   = auto  #[path2directory], auto for WEATHER_DIR or "./"

## Notes for height_correlation:
## Extra multilooking is applied to estimate the empirical phase/elevation ratio ONLY.
## For an dataset with 5 by 15 looks, looks=8 will generate phase with (5*8) by (15*8) looks
## to estimate the empirical parameter; then apply the correction to original phase (with 5 by 15 looks),
## if the phase/elevation correlation is larger than minCorrelation.
mintpy.troposphericDelay.polyOrder      = auto  #[1 / 2 / 3], auto for 1
mintpy.troposphericDelay.looks          = auto  #[1-inf], auto for 8, extra multilooking num
mintpy.troposphericDelay.minCorrelation = auto  #[0.0-1.0], auto for 0

########## 4. correct_unwrap_error (optional)
## connected components (mintpy.load.connCompFile) are required for this step.
## SNAPHU (Chem & Zebker,2001) is currently the only unwrapper that provides connected components as far as we know.
## reference: Yunjun et al. (2019, section 3)
## supported methods:
## a. phase_closure          - suitable for highly redundant network
## b. bridging               - suitable for regions separated by narrow decorrelated features, e.g. rivers, narrow water bodies
## c. bridging+phase_closure - recommended when there is a small percentage of errors left after bridging
mintpy.unwrapError.method          = no  #[bridging / phase_closure / bridging+phase_closure / no], auto for no
mintpy.unwrapError.waterMaskFile   = no  #[waterMask.h5 / no], auto for waterMask.h5 or no [if not found]
mintpy.unwrapError.connCompMinArea = 1   #[1-inf], auto for 2.5e3, discard regions smaller than the min size in pixels

## phase_closure options:
## numSample - a region-based strategy is implemented to speedup L1-norm regularized least squares inversion.
##     Instead of inverting every pixel for the integer ambiguity, a common connected component mask is generated,
##     for each common conn. comp., numSample pixels are radomly selected for inversion, and the median value of the results
##     are used for all pixels within this common conn. comp.
m
## Notes for gacos:
## Set the path below to directory that contains the downloaded *.ztd* files
mintpy.troposphericDelay.gacosDir = auto # [path2directory], auto for "./GACOS"


########## 7. deramp (optional)
## Estimate and remove a phase ramp for each acquisition based on the reliable pixels.
## Recommended for localized deformation signals, i.e. volcanic deformation, landslide and land subsidence, etc.
## NOT recommended for long spatial wavelength deformation signals, i.e. co-, post- and inter-seimic deformation.
mintpy.deramp          = linear  #[no / linear / quadratic], auto for no - no ramp will be removed
mintpy.deramp.maskFile = auto  #[filename / no], auto for maskTempCoh.h5, mask file for ramp estimation


########## 8. correct_topography (optional but recommended)
## Topographic residual (DEM error) correction
## reference: Fattahi and Amelung (2013, IEEE-TGRS)
## stepFuncDate      - specify stepFuncDate option if you know there are sudden displacement jump in your area,
##                     e.g. volcanic eruption, or earthquake
## excludeDate       - dates excluded for the error estimation
## pixelwiseGeometry - use pixel-wise geometry (incidence angle & slant range distance)
##                     yes - use pixel-wise geometry if they are available [slow; used by default]
##                     no  - use the mean   geometry [fast]
mintpy.topographicResidual                   = auto  #[yes / no], auto for yes
mintpy.topographicResidual.polyOrder         = auto  #[1-inf], auto for 2, poly order of temporal deformation model
mintpy.topographicResidual.phaseVelocity     = auto #[yes / no], auto for no - phase, use phase velocity for minimization
mintpy.topographicResidual.stepFuncDate      = auto  #[20080529,20190704T1733 / no], auto for no, date of step jump
mintpy.topographicResidual.excludeDate       = auto  #[20070321 / txtFile / no], auto for exclude_date.txt
mintpy.topographicResidual.pixelwiseGeometry = auto  #[yes / no], auto for yes, use pixel-wise geometry info


########## 9.1 residual_RMS (root mean squares for noise evaluation)
## Calculate the Root Mean Square (RMS) of residual phase time-series for each acquisition
## reference: Yunjun et al. (2019, section 4.9 and 5.4)
## To get rid of long spatial wavelength component, a ramp is removed for each acquisition
## Set optimal reference date to date with min RMS
## Set exclude dates (outliers) to dates with RMS > cutoff * median RMS (Median Absolute Deviation)
mintpy.residualRMS.maskFile = auto  #[file name / no], auto for maskTempCoh.h5, mask for ramp estimation
mintpy.residualRMS.deramp   = auto  #[quadratic / linear / no], auto for quadratic
mintpy.residualRMS.cutoff   = auto  #[0.0-inf], auto for 3

########## 9.2 reference_date
## Reference all time-series to one date in time
## reference: Yunjun et al. (2019, section 4.9)
## no     - do not change the default reference date (1st date)
mintpy.reference.date = auto  #[reference_date.txt / 20090214 / no], auto for reference_date.txt


########## 10. velocity
## Estimate a suite of time functions [linear velocity by default]
## from final displacement file (and from tropospheric delay file if exists)
mintpy.timeFunc.startDate   = auto   #[20070101 / no], auto for no
mintpy.timeFunc.endDate     = auto   #[20101230 / no], auto for no
mintpy.timeFunc.excludeDate = auto   #[exclude_date.txt / 20080520,20090817 / no], auto for exclude_date.txt

## Fit a suite of time functions
## reference: Hetland et al. (2012, JGR) equation (2-9)
## polynomial function    is  defined by its degree in integer. 1 for linear, 2 for quadratic, etc.
## periodic   function(s) are defined by a list of periods in decimal years. 1 for annual, 0.5 for semi-annual, etc.
## step       function(s) are defined by a list of onset times in str in YYYYMMDD(THHMM) format
## exp & log  function(s) are defined by an onset time followed by an charateristic time in integer days.
##   Multiple exp and log functions can be overlaied on top of each other, achieved via e.g.:
##   20110311,60,120          - two functions sharing the same onset time OR
##   20110311,60;20170908,120 - separated by ";"
mintpy.timeFunc.polynomial = auto   #[int >= 0], auto for 1, degree of the polynomial function
mintpy.timeFunc.periodic   = auto   #[1,0.5 / list_of_float / no], auto for no, periods in decimal years
mintpy.timeFunc.step       = auto   #[20110311,20170908 / 20120928T1733 / no], auto for no, step function(s)
mintpy.timeFunc.exp        = auto   #[20110311,60 / 20110311,60,120 / 20110311,60;20170908,120 / no], auto for no
mintpy.timeFunc.log        = auto   #[20110311,60 / 20110311,60,120 / 20110311,60;20170908,120 / no], auto for no

## Uncertainty quantification methods:
## a. residue    - propagate from fitting residue assuming normal dist. in time (Fattahi & Amelung, 2015, JGR)
## b. covariance - propagate from time series (co)variance matrix
## c. bootstrap  - bootstrapping (independently resampling with replacement; Efron & Tibshirani, 1986, Stat. Sci.)
mintpy.timeFunc.uncertaintyQuantification = auto   #[residue, covariance, bootstrap], auto for residue
mintpy.timeFunc.timeSeriesCovFile         = auto   #[filename / no], auto for no, time series covariance file
mintpy.timeFunc.bootstrapCount            = auto   #[int>1], auto for 400, number of iterations for bootstrapping


########## 11.1 geocode (post-processing)
# for input dataset in radar coordinates only
# commonly used resolution in meters and in degrees (on equator)
# 100,         90,          60,          50,          30,          20,          10
# 0.000925926, 0.000833334, 0.000555556, 0.000462963, 0.000277778, 0.000185185, 0.000092593
mintpy.geocode              = no   #[yes / no], auto for yes
mintpy.geocode.SNWE         = auto  #[-1.2,0.5,-92,-91 / none ], auto for none, output extent in degree
mintpy.geocode.laloStep     = auto  #[-0.000555556,0.000555556 / None], auto for None, output resolution in degree
mintpy.geocode.interpMethod = auto  #[nearest], auto for nearest, interpolation method
mintpy.geocode.fillValue    = auto  #[np.nan, 0, ...], auto for np.nan, fill value for outliers.

########## 11.2 google_earth (post-processing)
mintpy.save.kmz             = yes   #[yes / no], auto for yes, save geocoded velocity to Google Earth KMZ file

########## 11.3 hdfeos5 (post-processing)
mintpy.save.hdfEos5         = auto   #[yes / no], auto for no, save time-series to HDF-EOS5 format
mintpy.save.hdfEos5.update  = auto   #[yes / no], auto for no, put XXXXXXXX as endDate in output filename
mintpy.save.hdfEos5.subset  = auto   #[yes / no], auto for no, put subset range info   in output filename

########## 11.4 plot
# for high-resolution plotting, increase mintpy.plot.maxMemory
# for fast plotting with more parallelization, decrease mintpy.plot.maxMemory
mintpy.plot           = yes  #[yes / no], auto for yes, plot files generated by default processing to pic folder
mintpy.plot.dpi       = auto  #[int], auto for 150, number of dots per inch (DPI)
mintpy.plot.maxMemory = auto  #[float], auto for 4, max memory used by one call of view.py for plotting.